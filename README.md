# JPA

## 1.3 JPA란 무엇인가?
- 자바 진영의 ORM 기술 표준
- 애플리케이션과 JDBC 사이에서 동작
- EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어졌는데 이것이 바로 JPA
- 자바 ORM 기술에 대한 API 표준 명세 -> JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 하는데, 하이버네이트가 가장 대중적

## 2.6 애플리케이션 개발
- JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 함. 트랜잭션 없이 데이터를 변경하면 예외 발생.
- 트랜잭션을 시작하려면 엔티티 매니저에서 트랜잭션 API를 받아와야 함.

## 3.3 엔티티의 생명주기
- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태. "순수한 객체"
- 영속(managed): 영속성 컨텍스트에 저장된 상태 -> 영속성 컨텍스트에 의해 관리된다는 뜻!(em.find()나 JPQL을 사용해서 조회한 엔티티도!)
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태(em.close() 하거나 em.clear()해서 영속성 컨텍스트를 초기화해도 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 됨!)
- 삭제(removed): 삭제된 상태(영속성 컨텍스트, 데이터베이스 모두에서)

## 3.4 영속성 컨텍스트의 특징
- 영속 상태는 식별자 값이 반드시 있어야 함! -> 없으면 예외
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영!(flush)
- 영속성 컨텍스트는 내부에 캐시를 가지고 있는데, 이것이 1차 캐시. 영속 상태의 엔티티는 모두 이곳에 저장됨.
  em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 만약 찾는 엔티티가 없으면 데이터베이스에서 조회
- 쓰기 지연: 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모았다가 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보냄
- 트랜잭션을 커밋하면 엔티티 매니저는 우선 영속성 컨텍스트를 플러시(영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화=쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보냄)
- JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장(스냅샷) -> 플러시 시점에 스냅샷과 엔티티 비교해서 변경된 엔티티를 찾아 수정 쿼리 생성해서 쓰기 지연 SQL 저장소에 보냄
- 영속성 컨텍스트를 flush 하는 3가지 방법: 직접 호출, 트랜잭션 커밋 시 플러시 자동 호출, JPQL 쿼리 실행 시 플러시 자동 호출